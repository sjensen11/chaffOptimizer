classdef chaffElt
    %chaffElt Summary of this class goes here
    %   Detailed explanation goes here
    
    properties
        %given values
        freq %choosen frequency in Hz
        plateLength %size of the plate in meters
        %calculated values
        plateFull %contains solution for the a completely full plate(x,y positions here)
        plateNull %contains solutions with edges removed
        nullPos %matrix with row/col positions -> [r1,c1;r2,c2;...]
        
        %angle sweep
        thetaVals %theta (elevation) Values to be swept over
        phiVals %phi (azimuth) values to be swept over
        %values for plotting
        
    end
    
    methods
        function obj = chaffElt(freq,plateLength,thetaVals, phiVals,loadVal)
            %creates chf(freq,plateLength,thetaVals, phiVals,load) load is
            %an optional variable that loads a previously generated plate
            %to save time
            
            %set given values
            obj.freq = freq;
            obj.thetaVals = thetaVals;
            obj.phiVals = phiVals;
            obj.nullPos = [];
            obj.plateLength = plateLength;
            
            
            %make plate
            lambda = physconst('LightSpeed')./freq;
            plateLengthLambda = plateLength./lambda; %convert to lambda
            
            %want a minimum of lambda/10 divsion
            %divided by 1/10 so multiply by 10
            %need numcells to be the same regardless of lambda plate size,
            %so use same numcell
            NumCells = ceil(max(plateLengthLambda)*10)
            if(NumCells <10)
                NumCells = 16
            end
            if(mod(NumCells,2)) %force NumCells to be an even Number
                NumCells = NumCells+1
            end
            
            if(nargin>4 && loadVal) %load variable used and active (load==1)
                %this isn't fully realized and is me being lazy right now,
                %fix this later sarah 0_0
                %I forced the values above to give 2lambda plate length...
                %this is horrible coding practice right now because I am
                %lazy
                disp('this really only works for one freq... should update')
                disp(['plate length is ' num2str(plateLengthLambda)])
%                 disp(['what do you want to load? recomend plate' num2str(ceil(plateLengthLambda)*10)]) 
                loadPlate = input(['what do you want to load? recomend plate' num2str(ceil(plateLengthLambda)*10) ' '],'s');
                load(loadPlate); %gets plateLoad out of file
               	plate = plateLoad;
                disp([loadPlate ' loaded'])
            else
                plate = []; %set up plate
                for ii = 1:length(freq) %walk through frequencies
                    
                    %make plate and set plateFull and plateNull
                    plateTemp = thePlate(NumCells, plateLengthLambda(ii) ,0,0); %set original incident angles to zero

                    plate = [plate plateTemp.generateMatrix()]; %store in matrix
                    disp('generated plate')
                end
            end
            obj.plateFull = plate;
            obj.plateNull = plate;
            
            disp('chaff made')
        end
        
 %================= get values ============================================ 
 %they should all have the same size, because numCells
 %so just use the first plate in array
 %doing it this way, because it's a little more readable (I think)
        function numElt = getNumEltFull(obj)
            %returns the number of points for the full plate
            numElt = length(obj.plateFull(1).Bxn_xx)+length(obj.plateFull(1).Byn_xx);
        end

        function numElt = getNumEltNull(obj)
            %returns the number of points for the null plate
            numElt = length(obj.plateNull(1).Bxn_xx) + length(obj.plateNull.Byn_xx);
        end

        function numElt = getBxnSize(obj)
            %returns the length of BxnSize of the null plate (holes)
            numElt = length(obj.plateNull(1).Bxn_xx);
        end
        function numElt = getBxnSizeFull(obj)
            %returns the length of BxnSize of the full plate (no holes)
            numElt = length(obj.plateFull(1).Bxn_xx);
        end

        function numCells = getNumCellsRow(obj)
            %returns the number of cells in 1D for the full plate
            numCells = obj.plateFull(1).NumCells;
        end
        
        function numCells = getNumCellsFull(obj)
            numCells = obj.plateFull(1).NumCells^2;
        end
%===================== nulling fun ========================================
        function obj = removeNulls(obj)
            %used to remove null positions... should return to just metal
            %sheets
            obj.plateNull = obj.plateFull;
            obj.nullPos = [];
        end
        function obj = nullNew(obj,nullPos)
            %keep the same full plate, but null new values (ie, doesn't
            %retain past null Values)
            %nullpos gives a list of [rows,cols] that correspond to the
            %cells that are going to be nulled. However, current is defined
            %on the edges of a cell, so to null that cell, 4 edges have to
            %be zeroed out instead
            
            %get row/col
            row = nullPos(:,1);
            col = nullPos(:,2);
            

            %cells/edges per row/col (because assumed square)
            NumCells =obj.getNumCellsRow();
            NumEdge = NumCells-1;

            nullLen = size(nullPos,1);
            cellNum = zeros(1,nullLen);
            
            %sorting by cell number because why not? idk why I did this
            %convert row/col into edges
            for ii = 1:nullLen
                %just care about one edge... choose the smallest first
                rowVal = nullPos(ii,1); colVal = nullPos(ii,2);
                %because matlab starts at 1, move row/col to 0 and add 1 at the end
                cellNum(ii) = (rowVal-1)*(NumCells) +(colVal-1)+1;
            end
            
            [out,idx] = sort(cellNum); %trying to get index for sort
            nullPosOld = nullPos;

            for ii=1:nullLen
                nullPos(ii,:) = nullPosOld(idx(ii),:);
            end
            
            obj.nullPos = nullPos; %reset obj nullPos
            
            %-----------------start finding edges--------------------------
            
            %preallocate to max number of edges there could be, ie) 4 edges
            %per cell have use -1 because 0 is value played with ('0' edge 
            %is cancelled out)
            edgex = zeros(1,4*nullLen)-1; %[];
            edgey = zeros(1,4*nullLen)-1;%[];
            edgex_count = 1;
            edgey_count = 1;
            
            %-----do the first row-----
            indexEdge = find(row==1);
            rowOneVal_row = row(indexEdge);
            rowOneVal_col = col(indexEdge);
            %convert to edges
            for ii = 1:length(indexEdge)
                rowVal = rowOneVal_row(ii); colVal = rowOneVal_col(ii);

                %get the edge to right, left, top, and bottom
                edge1 = (rowVal-1)*(NumCells-1) +(colVal-1); 
                edge2 = (rowVal-1)*(NumCells-1) + colVal;
                %no edge3 because no bottom edge
                edge4 = (colVal-1)*(NumCells-1) +  rowVal;

                edgex(edgex_count:edgex_count+1) = [edge1 edge2];
                edgey(edgey_count) = edge4;

                edgex_count = edgex_count+2; %added 2 edges
                edgey_count = edgey_count+1; %added 1 edge

            end
            
            %deal with the corners
            edgex(edgex==0) = [];
            edgex(edgex==NumCells) = [];
            
            
            %-------------do the last row-----------------------
            indexEdge = find(row==NumCells);
            rowLastVal_row = row(indexEdge);
            rowLastVal_col = col(indexEdge);
            %convert to edges
            for ii = 1:length(indexEdge)
                rowVal = rowLastVal_row(ii); colVal = rowLastVal_col(ii);

                %get the edge to right, left, top, and bottom
                edge1 = (rowVal-1)*(NumCells-1) +(colVal-1);
                edge2 = (rowVal-1)*(NumCells-1) + colVal;
                edge3 = (colVal-1)*(NumCells-1) + (rowVal-1);
                %no edge4 because no top edge

                edgex(edgex_count:edgex_count+1) = [edge1 edge2];
                edgey(edgey_count) = edge3;

                edgex_count = edgex_count+2; %added 2 edges
                edgey_count = edgey_count+1; %added 1 edge

            end

            %deal with the corners
            topCellPos = NumCells*NumEdge;%actual number of cells total or top right cell number
            edgex(edgex==topCellPos-NumCells+1) = [];
            edgex(edgex==topCellPos+1) = [];
            
            %------------first col---------------
            indexEdge = find(col==1);
            colOneVal_row = row(indexEdge);
            colOneVal_col = col(indexEdge);

            %convert to edges
            for ii = 1:length(indexEdge)
                rowVal = colOneVal_row(ii); colVal = colOneVal_col(ii);

                %get the edge to right, left, top, and bottom
                %no edge1 because no col to the left
                edge2 = (rowVal-1)*(NumCells-1) + colVal;
                edge3 = (colVal-1)*(NumCells-1) + (rowVal-1);
                edge4 = (colVal-1)*(NumCells-1) +  rowVal;%no edge4 because no top edge

                edgex(edgex_count) = edge2;
                edgey(edgey_count:edgey_count+1) = [edge3 edge4];

                edgex_count = edgex_count+1; %added 1 edge
                edgey_count = edgey_count+2; %added 2 edge

            end

            %deal with the corners
            edgey(edgey==0) = [];
            edgey(edgey==NumCells) = [];


            %------last col-------------
            indexEdge = find(col==NumCells);
            colLastVal_row = row(indexEdge);
            colLastVal_col = col(indexEdge);

            %convert to edges
            for ii = 1:length(indexEdge)
                rowVal = colLastVal_row(ii); colVal = colLastVal_col(ii);

                %get the edge to right, left, top, and bottom
                edge1 = (rowVal-1)*(NumCells-1) +(colVal-1);
                %no edge2 because no right edge
                edge3 = (colVal-1)*(NumCells-1) + (rowVal-1);
                edge4 = (colVal-1)*(NumCells-1) +  rowVal;

                edgex(edgex_count) = edge1;
                edgey(edgey_count:edgey_count+1) = [edge3 edge4];

                edgex_count = edgex_count+1; %added 1 edge
                edgey_count = edgey_count+2; %added 2 edge


            end

            %deal with the corners
            topCellPos = NumCells*NumEdge;%actual number of cells total or top right cell number
            edgey(edgey==topCellPos-NumCells+1) = [];
            edgey(edgey==topCellPos+1) = [];
            
            
            %-------- find everything else -----------------
            % if this reads wierd it's because of how the code was written! I wrote
            % this part first and it works, so I don't want mess with it to much

            %rowBad/colBad are not related to the position to be nulled. It's just the
            %position in nullpos that contains a '1'. I don't care whether that's a row
            %or col. The entire postition need to be wiped. ->why I'm not using colBad
            %for anything

            innerNulls = nullPos; %want to save nullPos right now
            [rowBad, colBad] = find(innerNulls==1); %right next to the edge
            innerNulls(rowBad,:) = [];

            [rowBad,colBad] = find(innerNulls==NumCells);
            innerNulls(rowBad,:) = [];

            for ii = 1:size(innerNulls,1)
                rowVal = innerNulls(ii,1); colVal = innerNulls(ii,2); 
                %edge 1,2 next to eachother and 3,4 next to eachother
                edge1 = (rowVal-1)*(NumCells-1) +(colVal-1); %each time through removes one edge previous
                edge2 = (rowVal-1)*(NumCells-1) + colVal;
                edge3 = (colVal-1)*(NumCells-1) + (rowVal-1);
                edge4 = (colVal-1)*(NumCells-1) +  rowVal;

                edgex(edgex_count:edgex_count+1) = [edge1 edge2];
                edgey(edgey_count:edgey_count+1) = [edge3 edge4];

                edgex_count = edgex_count+2; %added 2 edges
                edgey_count = edgey_count+2; %added 2 edges
            end
            
            %throw out uncessary allocation 
            edgex(edgex==-1) = [];
            edgey(edgey==-1) = [];
            
            %finally get values
            edgex = unique(edgex);
            edgey = unique(edgey);
            
            %now we can walk through the different plates
            for ii = 1:length(obj.freq)

                %remove points from zz, Bxn, Byn, ex, ey
                %zz(badVal) = [] to remove
                %first shift edgey up by new "M", peterson pg417 because of how
                %we're counting zz and ee... original M is length(Bxn) subtract
                %the removed points -> bxn-length(edgex)
                %get plate info
                plateF = obj.plateFull(ii); 
                zzLoc = plateF.ZZ;
                plateN = plateF; %start with full plate

                %shiftup value needed for y directed current... ie)M+1 in
                %peterson sum pg417
                edgeyshiftup = obj.getBxnSizeFull()-length(edgex)+edgey; 

                zzLoc(:,edgex) = [];
                zzLoc(edgex,:) = [];

                zzLoc(edgeyshiftup,:) = [];
                zzLoc(:,edgeyshiftup) = [];

                plateN.EE_theta(edgex) = [];
                plateN.EE_theta(edgeyshiftup) = [];
                
                plateN.EE_phi(edgex) = [];
                plateN.EE_phi(edgeyshiftup) = [];

                plateN.Bxn_xx(edgex) = [];
                plateN.Bxn_yy(edgex) = [];

                plateN.Byn_xx(edgey) = [];
                plateN.Byn_yy(edgey) = [];

                %store local zz as ZZ in obj
                plateN.ZZ = zzLoc;
                plateN.ZZinv= inv(zzLoc);

                %set plateNull
                plateN.JJ_theta = plateN.ZZinv*plateN.EE_theta;
                plateN.JJ_phi = plateN.ZZinv*plateN.EE_phi;
                obj.plateNull(ii) = plateN;
                obj.nullPos = nullPos;
            end
        end
%================= playing with Einc =================================      

        function obj = changeEinc(obj,phiInc,thetaInc)
            %change Einc on both the null plate and full plate
            for ii = 1:length(obj.freq)
                plateF = obj.plateFull(ii);
                plateN = obj.plateNull(ii);
                
                obj.plateFull(ii) = plateF.changeEinc(phiInc,thetaInc);
                obj.plateNull(ii) = plateN.changeEinc(phiInc,thetaInc);
            end
        end
        
        
        
%================= stuff for optimization =================================            
        function obj = nullNewFromOneArray(obj,xx)
            %nulls based off the [0/1] array found from null2minRCS ga
            %function
            
            NumCells = obj.getNumCellsRow();
            [row,col] = obj.array2rowcol(xx, NumCells);
            nullpos = [row' col'];
            %rewrite 
            obj = obj.nullNew(nullpos);
        end
        
        function avgRCS = null2minRCS(obj,xx,thetaScat,phiScat)
            %use this function to null values, and then get the RCS value 
            NumCells = obj.getNumCellsRow();
            %xx is a series of zeros and one, zero means null that position
            [row,col] = obj.array2rowcol(xx, NumCells);
            nullpos = [row' col'];

            %walk through frequencies
            freqLen = length(obj.freq);
            avgRCS = 0;
            for ii = 1:freqLen
                %rewrite 
                obj = obj.nullNew(nullpos);

                %get rcs
                [rcstt,rcstp,rcspt,rcspp] =  obj.plateNull(ii).getRCSVal(thetaScat,phiScat); %at main beam
                %want to not consider cross polar, because they should be
                %zero
                avgRCS = (rcstt+rcspp)/2;
            end
            
        end
        %pretty sure this function is unused now, but commenting in case
%         function rcs = null2minRCSQuarter(obj,xx,thetaInc,phiInc)
%             %use this function to null values, and then get the RCS value 
%             NumCells = obj.getNumCellsRow();
%             NumCellsQuarter = NumCells/2;
%             %xx is a series of zeros and one, zero means null that position
%             [row,col] = obj.array2rowcol(xx, NumCellsQuarter);
%             nullpos = [row' col'];
% 
%             %rewrite 
%             obj = obj.nullNew(nullpos);
%             
%             %get rcsxx
%             
%             rcs = obj.plateNull.getRCSVal(thetaInc,phiInc); %at main beam
%         end
        
        function avgRCS = null2minRCSAvg(obj,xx)
            %seeks to minimize(minus sign in ga makes it maxize) the
            %average RCS over various angles of incidence
            %xx is a series of zeros and one, zero means null that position
            %and is feed into null2minRCS(obj,xx)
            %note: null2minRCS returns the average rcs over all polarizations
            %   ie) (rcs_tt+rcs_tp+rcs_pt+rcs_pp)/4 where p=phi, t = theta
            
            numThetaAngles = length(obj.thetaVals);
            numPhiAngles = length(obj.phiVals);
            rcsSum = 0;
            
            for ii = 1:numThetaAngles
                for jj =1:numPhiAngles
                    obj = obj.changeEinc(obj.phiVals(jj),obj.thetaVals(ii));
                    rcsSum = rcsSum + obj.null2minRCS(xx,obj.thetaVals(ii),obj.phiVals(jj));
                end
            end
            avgRCS = rcsSum/(numThetaAngles*numPhiAngles);
        end
        
        function avgRCS = null2minRCSAvgQuarter(obj,xxQuarter)
            %seeks to minimize(minus sign in ga makes it maxize) the
            %average RCS over various angles of incidence
            %xx is a series of zeros and one, zero means null that position
            %and is feed into null2minRCS(obj,xx)
            %tries to do some symmettry magic
            
            %take the one quarter and make into the full array
            NumCells= obj.getNumCellsRow;
            fullArray = obj.quarter2FullArray(xxQuarter,NumCells);
            
            %null2minRCS code from before
            avgRCS = obj.null2minRCSAvg(fullArray);
        end
        
        
        function [phi,rcs] = getRCS(obj,theta,plot)
            %returns RCS of the chaff element... actual code is sitting in thePlate class
            %plot=0 no plot, plot=1 plot dB, plot = 2 plot RCS normal
            [phi,rcs] = obj.plateNull.getRCS(theta,plot);
        end
%======================== optimize code ===================================        
        function [chfNulled,pointsOnVal,RCSavg] = maximizeRCSAvg(obj)
            %runs the genetic algorithm code... the range of angles can be
            %found in chf.null2minRCSAvg
            %this function assumes nothing and just will brute force the
            %issue
            %think i care about cells on
            numPoints = obj.getNumCellsFull(); %size of Full plate

            pointsOn_lb = zeros(numPoints,1);
            pointsOn_ub = ones(numPoints,1);
            options = gaoptimset('PlotFcns',...
             {@gaplotbestf,@gaplotbestindiv,@gaplotexpectation,@gaplotstopping});
            options = gaoptimset(options,'StallGenLimit',100);
            options = gaoptimset(options,'Generations',100);

            options = gaoptimset(options,'TolFun',1e-15);
            Intcon=1:numPoints;
            %maximizing center main beam
            tic
            [pointsOnVal,RCSavg] = ga(@(pointsOn) -obj.null2minRCSAvg(pointsOn),numPoints,[],[],[],[],pointsOn_lb,pointsOn_ub,[],Intcon,options);
            toc  

            chfNulled = obj.nullNewFromOneArray(pointsOnVal); 
        end
%==========================================================================
        function [chfNulled,pointsOnFull,RCSavg] = maximizeRCSAvgSymm(obj)
            %runs the genetic algorithm code... the range of angles can be
            %found in chf.null2minRCSAvg
            %tries to build in some symettry assumes each quarter has to
            %"look" the same ie) if top left is tt then whole matrix will
            %be [tt fliplr(tt); flipud(tt) fliplr(flipud(tt))]
            disp('starting optimizaton for symmetric chaff')
            numCellsFull = obj.getNumCellsRow(); %Number of cells of full plate
            numCellsQuarter = numCellsFull/2; %number of cells in one quarter
            numPoints = numCellsQuarter^2; %number of points in a quarter

            pointsOn_lb = zeros(numPoints,1);
            pointsOn_ub = ones(numPoints,1);
            options = gaoptimset('PlotFcns',...
             {@gaplotbestf,@gaplotbestindiv,@gaplotexpectation,@gaplotstopping});
            options = gaoptimset(options,'StallGenLimit',50);
            options = gaoptimset(options,'Generations',50);

            options = gaoptimset(options,'TolFun',1e-15);
            Intcon=1:numPoints;
            %maximizing center main beam
            tic
            [pointsOnVal,RCSavg] = ga(@(pointsOn) -obj.null2minRCSAvgQuarter(pointsOn),numPoints,[],[],[],[],pointsOn_lb,pointsOn_ub,[],Intcon,options);
            toc  
            
            %pointsOnVal is just quarter cell, get full array
            pointsOnFull = obj.quarter2FullArray(pointsOnVal,numCellsFull);

            %return nulled chaff
            chfNulled = obj.nullNewFromOneArray(pointsOnFull); 
        end
        
        function [chfNulled,pointsOnFull,RCSavg] = maximizeRCSAvgSymmPatternSearch(obj)
            %runs the genetic algorithm code... the range of angles can be
            %found in chf.null2minRCSAvg
            %tries to build in some symettry assumes each quarter has to
            %"look" the same ie) if top left is tt then whole matrix will
            %be [tt fliplr(tt); flipud(tt) fliplr(flipud(tt))]
            disp('starting optimizaton for symmetric chaff')
            numCellsFull = obj.getNumCellsRow(); %Number of cells of full plate
            numCellsQuarter = numCellsFull/2; %number of cells in one quarter
            numPoints = numCellsQuarter^2; %number of points in a quarter
            startOn = zeros(1,numPoints); %initial guess, metal plate

            pointsOn_lb = zeros(numPoints,1);
            pointsOn_ub = ones(numPoints,1);
            options = optimoptions('patternsearch','ScaleMesh','off','Plo)

            Intcon=1:numPoints;
            %maximizing center main beam
            tic
            [pointsOnVal,RCSavg] = patternsearch(@(pointsOn) -obj.null2minRCSAvgQuarter(pointsOn),startOn,[],[],[],[],pointsOn_lb,pointsOn_ub,options);
            toc  
            
            %pointsOnVal is just quarter cell, get full array
            pointsOnFull = obj.quarter2FullArray(pointsOnVal,numCellsFull);

            %return nulled chaff
            chfNulled = obj.nullNewFromOneArray(pointsOnFull); 
        end
%======================= plot RCS stuff ===================================
        function [theta,rcsTT, rcsPT, rcsTP, rcsPP] =  getBiRCSVals(obj,phi)
            %returns the bistatic radar cross-section... rows are each
            %individual frequency ie) rcsNull(1) is the first plate
            %response
            %give phi a default value of 0
            if(nargin <2)
                phi = 0; 
            end
           
            numVals = 360;
            theta = linspace(-pi/2,pi/2,numVals);%only need top of plate :Plinspace(0,2*pi,numVals);
            freqLen = length(obj.freq);
            
            %pre-allocate matrix
            rcsTT = zeros(freqLen,numVals);
            rcsPT = zeros(freqLen,numVals);
            rcsTP = zeros(freqLen,numVals);
            rcsPP = zeros(freqLen,numVals);
            
            for jj = 1:freqLen
                for ii = 1:numVals
                    [rcstt,rcstp,rcspt,rcspp] = obj.plateNull(jj).getRCSVal(theta(ii),phi);

                    rcsTT(jj,ii) = rcstt;
                    rcsPT(jj,ii) = rcstp;
                    rcsTP(jj,ii) = rcspt;
                    rcsPP(jj,ii) = rcspp;

                end
            end
        end
        
        function [theta,rcsTT, rcsPT, rcsTP, rcsPP] =  getBiRCSValsFULL(obj,phi)
            %If you want to compare the null vs the full plate, this
            %returns the bistatic rcs of the metal sheet
            
            if(nargin <2)
                phi = 0; 
            end
           
            numVals = 360;
            theta =linspace(-pi/2,pi/2,numVals);%only need top of plate :Plinspace(0,2*pi,numVals);
            freqLen = length(obj.freq);
            
            %pre-allocate matrix
            rcsTT = zeros(freqLen,numVals);
            rcsPT = zeros(freqLen,numVals);
            rcsTP = zeros(freqLen,numVals);
            rcsPP = zeros(freqLen,numVals);
            
            for jj = 1:freqLen
                for ii = 1:numVals
                    [rcstt,rcstp,rcspt,rcspp] = obj.plateNull(jj).getRCSVal(theta(ii),phi);

                    rcsTT(jj,ii) = rcstt;
                    rcsPT(jj,ii) = rcstp;
                    rcsTP(jj,ii) = rcspt;
                    rcsPP(jj,ii) = rcspp;

                end
            end
        end
        
        function plotBiRCS(obj,phi,polar)
            %plots biRCS of null plate
            %defaults to polar plot
            if(nargin <3)
                polar = 1;
            end
            [theta,rcsTT, rcsPT, rcsTP, rcsPP] =  obj.getBiRCSVals(phi);
            
            freqLen = length(obj.freq);
            if(polar)
                for ii= 1:freqLen
                    figure;
                    subplot(1,4,1);title('rcs_tt')
                        polarplot(theta,10*log10(rcsTT(ii,:)));
                    subplot(1,4,2);title('rcs_pt')
                        polarplot(theta,10*log10(rcsPT(ii,:)));
                    subplot(1,4,3);title('rcs_tp')
                        polarplot(theta,10*log10(rcsTP(ii,:)));
                    subplot(1,4,4);title('rcs_pp')
                        polarplot(theta,10*log10(rcsPP(ii,:)));
                end
            else
            end
        end
        %------------------mono rcs -------------
        function [theta,rcsTT, rcsPT, rcsTP, rcsPP] =  getMonoRCSVals(obj,phi)
            %returns the bistatic radar cross-section... rows are each
            %individual frequency ie) rcsNull(1) is the first plate
            %response
            %give phi a default value of 0
            if(nargin <2)
                phi = 0; 
            end
           
            numVals = 360;
            theta = linspace(-pi/2,pi/2,numVals);%only need top of plate :Plinspace(0,2*pi,numVals);
            freqLen = length(obj.freq);
            
            %pre-allocate matrix
            rcsTT = zeros(freqLen,numVals);
            rcsPT = zeros(freqLen,numVals);
            rcsTP = zeros(freqLen,numVals);
            rcsPP = zeros(freqLen,numVals);
            
            for jj = 1:length(obj.freq)
                for ii = 1:numVals
                    plateN = obj.plateNull(jj).changeEinc(phi,theta(ii));
                    [rcstt,rcstp,rcspt,rcspp] = plateN.getRCSVal(theta(ii),phi);

                    rcsTT(jj,ii) = rcstt;
                    rcsPT(jj,ii) = rcstp;
                    rcsTP(jj,ii) = rcspt;
                    rcsPP(jj,ii) = rcspp;

                end
            end
        end
        
        function [rcsTT, rcsPT, rcsTP, rcsPP] =  getMonoRCSValsOPT(obj,phi)
            %returns the bistatic radar cross-section at optimized theta 
            %angles, asssumes we're feeding a "correct" phival... rows are each
            %individual frequency ie) rcsNull(1) is the first plate
            %response
            %give phi a default value of obj.phiVals(1), you can feed
            %phi!=phivals, please don't
            if(nargin <2)
                phi = obj.phiVals; 
            end
           
            
            theta = obj.thetaVals;%only need top of plate :Plinspace(0,2*pi,numVals);
            thetaLen = length(theta);
            freqLen = length(obj.freq);
            
            %pre-allocate matrix
            rcsTT = zeros(freqLen,thetaLen);
            rcsPT = zeros(freqLen,thetaLen);
            rcsTP = zeros(freqLen,thetaLen);
            rcsPP = zeros(freqLen,thetaLen);
            
            for jj = 1:length(obj.freq)
                for ii = 1:thetaLen
                    plateN = obj.plateNull(jj).changeEinc(phi,theta(ii));
                    [rcstt,rcstp,rcspt,rcspp] = plateN.getRCSVal(theta(ii),phi);

                    rcsTT(jj,ii) = rcstt;
                    rcsPT(jj,ii) = rcstp;
                    rcsTP(jj,ii) = rcspt;
                    rcsPP(jj,ii) = rcspp;

                end
            end
        end
        
        function [theta,rcsTT, rcsPT, rcsTP, rcsPP] =  getMonoRCSValsFULL(obj,phi)
            %returns the bistatic radar cross-section... rows are each
            %individual frequency ie) rcsNull(1) is the first plate
            %response
            %gives the full plate... mostly using to compare against nulled
            %plate
            %give phi a default value of 0
            if(nargin <2)
                phi = 0; 
            end
           
            numVals = 360;
            theta = linspace(-pi/2,pi/2,numVals);%only need top of plate :Plinspace(0,2*pi,numVals);
            freqLen = length(obj.freq);
            
            %pre-allocate matrix
            rcsTT = zeros(freqLen,numVals);
            rcsPT = zeros(freqLen,numVals);
            rcsTP = zeros(freqLen,numVals);
            rcsPP = zeros(freqLen,numVals);
            
            for jj = 1:length(obj.freq)
                for ii = 1:numVals
                    plateF = obj.plateFull(jj).changeEinc(phi,theta(ii));
                    [rcstt,rcstp,rcspt,rcspp] = plateF.getRCSVal(theta(ii),phi);

                    rcsTT(jj,ii) = rcstt;
                    rcsPT(jj,ii) = rcstp;
                    rcsTP(jj,ii) = rcspt;
                    rcsPP(jj,ii) = rcspp;

                end
            end
        end
       
        function plotMonoStaticRCS(obj,phi,polar)
            %plots the monostatic RCS over the given theta values
            %returns raw RCS, not dB
            if(nargin <3)
                polar = 1;
            end
            [theta,rcsTT, rcsPT, rcsTP, rcsPP] =  getMonoRCSVals(obj,phi);
            freqLen = length(obj.freq);
            
            if(polar)
                for ii= 1:freqLen
                    figure;
                    subplot(1,4,1);title(['rcs_tt freq= ' num2str(obj.freq(ii)) 'Ghz'])
                        polarplot(theta,10*log10(rcsTT(ii,:)));
                    subplot(1,4,2);title('rcs_pt')
                        polarplot(theta,10*log10(rcsPT(ii,:)));
                    subplot(1,4,3);title('rcs_tp')
                        polarplot(theta,10*log10(rcsTP(ii,:)));
                    subplot(1,4,4);title('rcs_pp')
                        polarplot(theta,10*log10(rcsPP(ii,:)));
                end
            else
                for ii= 1:freqLen
                    figure;
                    subplot(1,4,1);title(['rcs_tt freq= ' num2str(obj.freq(ii)) 'Ghz'])
                        plot(theta,10*log10(rcsTT(ii,:)));
                    subplot(1,4,2);title('rcs_pt')
                        plot(theta,10*log10(rcsPT(ii,:)));
                    subplot(1,4,3);title('rcs_tp')
                        plot(theta,10*log10(rcsTP(ii,:)));
                    subplot(1,4,4);title('rcs_pp')
                    plot(theta,10*log10(rcsPP(ii,:)));
                end
            end
        end
        
        function plotMonoImprove(obj,phi,polar)
            %plots theta_theta and phi_phi monoRCS of both the metal and
            %whole plate
            %polar = 1: plots polar, polar=0 plots rectangular... defaults
            %to 1
            %listen, this isn't super smart... I'm assuming you're feeding
            %it a "correct" phi, I'm just using phi = 0 tbh
            if(nargin <3)
                polar = 1;
            end
            %get rcs values for null plate and full plate
            [theta,rcsTT, rcsPT, rcsTP, rcsPP] =  getMonoRCSVals(obj,phi);
            [theta,rcsTTFULL, rcsPTFULL, rcsTPFULL, rcsPPFULL] =  getMonoRCSValsFULL(obj,phi);
            
            %get optimized points
            [rcsTTOPT, rcsPTOPT, rcsTPOPT, rcsPPOPT] =  getMonoRCSValsOPT(obj,phi);

            freqLen = length(obj.freq);
            if(polar)
                for ii= 1:freqLen
                    figure;
                    %theta-theta polarization
                    subplot(1,2,1);
                        polarplot(theta,10*log10(rcsTT(ii,:)),theta,10*log10(rcsTTFULL(ii,:)) );
                        hold on
                        polarscatter(obj.thetaVals,10*log10(rcsTTOPT(ii,:))) %optimized theta points
                        title(['rcs tt(dB) freq= ' obj.freq(ii) 'Ghz'])
                        xlabel('theta_{inc} in radians');ylabel('monorcs (dB)')
                        ylim([min(10*log10(rcsTT(ii,:))) max(10*log10(rcsTT(ii,:)))])
                    %phipolarizatoin    
                    subplot(1,2,2);title(['rcs pp(dB) freq= ' num2str(obj.freq(ii)*10^-9) 'Ghz'])
                        polarplot(theta,10*log10(rcsPP(ii,:)),theta,10*log10(rcsPPFULL(ii,:)));
                        hold on
                        polarscatter(obj.thetaVals,10*log10(rcsPPOPT(ii,:))) %optimized theta points
                        title(['rcs_pp(dB) freq= ' num2str(obj.freq(ii)*10^-9) 'Ghz'])
                        xlabel('theta_{inc} in radians');ylabel('monorcs (dB)')
                        ylim([min(10*log10(rcsPP(ii,:))) max(10*log10(rcsPP(ii,:)))])
                end
            else
                for ii= 1:freqLen
                    figure;
                    subplot(1,2,1);
                        plot(theta,10*log10(rcsTT(ii,:)),theta,10*log10(rcsTTFULL(ii,:)) );
                        hold on
                        scatter(obj.thetaVals,10*log10(rcsTTOPT(ii,:))) %optimized theta points
                        title(['rcs tt(dB) freq= ' num2str(obj.freq(ii)*10^-9) 'Ghz'])
                        xlabel('theta_{inc} in radians');ylabel('monorcs (dB)')
                        ylim([min(10*log10(rcsTT(ii,:))) max(10*log10(rcsTT(ii,:)))])
                    subplot(1,2,2);
                        plot(theta,10*log10(rcsPP(ii,:)),theta,10*log10(rcsPPFULL(ii,:)) );
                        hold on
                        scatter(obj.thetaVals,10*log10(rcsPPOPT(ii,:))) %optimized theta points
                        title(['rcs pp(dB) freq= ' num2str(obj.freq(ii)*10^-9) 'Ghz'])
                        xlabel('theta_{inc} in radians');ylabel('monorcs (dB)')
%                         ylim([min(10*log10(rcsPP(ii,:))) max(10*log10(rcsPP(ii,:)))])
                end
            end
            
        end

        
        function avgRCS = compareRCS(obj)
            %DOESN'T WORK!!! think this is a bad idea so ignoring
            %looks at the average RCS over defined range and sees if it
            %improved
            %This returns a matrix of the avg rcs over the given angles for
            %each frequency
            %just want to check and make sure it's 'improving'
            thetaLoc = obj.thetaVals;
            phiLoc = obj.phiVals;
            avgRCS = zeros(1,length(obj.freq));
            for pp = 1:length(obj.freq) %walk through frequency
                plateN = obj.plateNull(pp)
                rcsTemp = 0;
                for ii = 1:length(thetaLoc)
                    for jj = 1:length(phiLoc)
                        [rcstt,rcstp,rcspt,rcspp] = obj.plateNull.getRCSVal(thetaLoc(ii),phiLoc(jj));
                    end
                end
                
            end
            
        end
        
        
        
% ============== old code ==========================        
        function plotEincRangeRCS(obj,phiIncRange,thetaVal)
            %DOESN'T WORK!! FIX!!!
            %plots the RCS at phi = 0 over different Einc (changing phiInc
            %angles)
            %mostly for testing just want to see what happens when plotted
            if (length(phiIncRange)>15)
                error('I didnt program this far. only can do 15 max...')
            end
            figure;
            for ii = 1:length(phiIncRange)
                chfTemp = obj.changeEinc(phiIncRange(ii),thetaVal);
                [theta,rcs] = chfTemp.plateNull.getRCS(0,0); %don't plot here, plot below so it goes to subplot
                subplot(3,5,ii); polarplot(theta,10*log10(rcs));
                title(['\phi_{inc}= ',num2str(phiIncRange(ii))])
            end
            
            figure
            for ii=1:length(phiIncRange)
                chfTemp = obj.changeEinc(phiIncRange(ii),thetaVal);
                [theta,rcs] = chfTemp.plateFull.getRCS(0,0); %don't plot here, plot below so it goes to subplot
                subplot(3,5,ii); polarplot(theta,10*log10(rcs));
                title(['\phi_{inc}= ',num2str(phiIncRange(ii))])
            end
            
        end
        
%==========================================================================
%plotting current
        function [JJx_theta, JJy_theta, JJx_phi, JJy_phi] = plotCurrent(obj)
            %plot the current of the null plate... idea is to take the code
            %from nullNew but instead of removing values just zeroing them
            %out... this means I need to find all the edges again. Then
            %take plateFull.JJ(edges) = 0
            
            %get some values
            %get plate
            plateF = obj.plateFull;
            %get nulls
            nullPosLoc = obj.nullPos;
            %size of Bxn... M in person sum p417
            %need the full plate Bxn
            bxn_len = obj.getBxnSizeFull();
            
            %check to see if nullPos actually has values to play with
            if(nullPosLoc) 
                %get row/col
                row = nullPosLoc(:,1);
                col = nullPosLoc(:,2);

                %cells/edges per row/col (because assumed square)
                NumCells =obj.getNumCellsRow();
                NumEdge = NumCells-1;

                nullLen = size(nullPosLoc,1);
                cellNum = zeros(1,nullLen);

                %sorting by cell number because why not? idk why I did this
                %convert row/col into edges
                for ii = 1:nullLen
                    %just care about one edge... choose the smallest first
                    rowVal = nullPosLoc(ii,1); colVal = nullPosLoc(ii,2);
                    %because matlab starts at 1, move row/col to 0 and add 1 at the end
                    cellNum(ii) = (rowVal-1)*(NumCells) +(colVal-1)+1;
                end

                [out,idx] = sort(cellNum); %trying to get index for sort
                nullPosOld = nullPosLoc;

                for ii=1:nullLen
                    nullPosLoc(ii,:) = nullPosOld(idx(ii),:);
                end



                %-----------------start finding edges--------------------------

                %preallocate to max number of edges there could be, ie) 4 edges
                %per cell have use -1 because 0 is value played with ('0' edge 
                %is cancelled out)
                edgex = zeros(1,4*nullLen)-1; %[];
                edgey = zeros(1,4*nullLen)-1;%[];
                edgex_count = 1;
                edgey_count = 1;

                %-----do the first row-----
                indexEdge = find(row==1);
                rowOneVal_row = row(indexEdge);
                rowOneVal_col = col(indexEdge);
                %convert to edges
                for ii = 1:length(indexEdge)
                    rowVal = rowOneVal_row(ii); colVal = rowOneVal_col(ii);

                    %get the edge to right, left, top, and bottom
                    edge1 = (rowVal-1)*(NumCells-1) +(colVal-1); 
                    edge2 = (rowVal-1)*(NumCells-1) + colVal;
                    %no edge3 because no bottom edge
                    edge4 = (colVal-1)*(NumCells-1) +  rowVal;

                    edgex(edgex_count:edgex_count+1) = [edge1 edge2];
                    edgey(edgey_count) = edge4;

                    edgex_count = edgex_count+2; %added 2 edges
                    edgey_count = edgey_count+1; %added 1 edge

                end

                %deal with the corners
                edgex(edgex==0) = [];
                edgex(edgex==NumCells) = [];


                %-------------do the last row-----------------------
                indexEdge = find(row==NumCells);
                rowLastVal_row = row(indexEdge);
                rowLastVal_col = col(indexEdge);
                %convert to edges
                for ii = 1:length(indexEdge)
                    rowVal = rowLastVal_row(ii); colVal = rowLastVal_col(ii);

                    %get the edge to right, left, top, and bottom
                    edge1 = (rowVal-1)*(NumCells-1) +(colVal-1);
                    edge2 = (rowVal-1)*(NumCells-1) + colVal;
                    edge3 = (colVal-1)*(NumCells-1) + (rowVal-1);
                    %no edge4 because no top edge

                    edgex(edgex_count:edgex_count+1) = [edge1 edge2];
                    edgey(edgey_count) = edge3;

                    edgex_count = edgex_count+2; %added 2 edges
                    edgey_count = edgey_count+1; %added 1 edge

                end

                %deal with the corners
                topCellPos = NumCells*NumEdge;%actual number of cells total or top right cell number
                edgex(edgex==topCellPos-NumCells+1) = [];
                edgex(edgex==topCellPos+1) = [];

                %------------first col---------------
                indexEdge = find(col==1);
                colOneVal_row = row(indexEdge);
                colOneVal_col = col(indexEdge);

                %convert to edges
                for ii = 1:length(indexEdge)
                    rowVal = colOneVal_row(ii); colVal = colOneVal_col(ii);

                    %get the edge to right, left, top, and bottom
                    %no edge1 because no col to the left
                    edge2 = (rowVal-1)*(NumCells-1) + colVal;
                    edge3 = (colVal-1)*(NumCells-1) + (rowVal-1);
                    edge4 = (colVal-1)*(NumCells-1) +  rowVal;%no edge4 because no top edge

                    edgex(edgex_count) = edge2;
                    edgey(edgey_count:edgey_count+1) = [edge3 edge4];

                    edgex_count = edgex_count+1; %added 1 edge
                    edgey_count = edgey_count+2; %added 2 edge

                end

                %deal with the corners
                edgey(edgey==0) = [];
                edgey(edgey==NumCells) = [];


                %------last col-------------
                indexEdge = find(col==NumCells);
                colLastVal_row = row(indexEdge);
                colLastVal_col = col(indexEdge);

                %convert to edges
                for ii = 1:length(indexEdge)
                    rowVal = colLastVal_row(ii); colVal = colLastVal_col(ii);

                    %get the edge to right, left, top, and bottom
                    edge1 = (rowVal-1)*(NumCells-1) +(colVal-1);
                    %no edge2 because no right edge
                    edge3 = (colVal-1)*(NumCells-1) + (rowVal-1);
                    edge4 = (colVal-1)*(NumCells-1) +  rowVal;

                    edgex(edgex_count) = edge1;
                    edgey(edgey_count:edgey_count+1) = [edge3 edge4];

                    edgex_count = edgex_count+1; %added 1 edge
                    edgey_count = edgey_count+2; %added 2 edge


                end

                %deal with the corners
                topCellPos = NumCells*NumEdge;%actual number of cells total or top right cell number
                edgey(edgey==topCellPos-NumCells+1) = [];
                edgey(edgey==topCellPos+1) = [];


                %-------- find everything else -----------------
                % if this reads wierd it's because of how the code was written! I wrote
                % this part first and it works, so I don't want mess with it to much

                %rowBad/colBad are not related to the position to be nulled. It's just the
                %position in nullpos that contains a '1'. I don't care whether that's a row
                %or col. The entire postition need to be wiped. ->why I'm not using colBad
                %for anything

                innerNulls = nullPosLoc; %want to save nullPos right now
                [rowBad, colBad] = find(innerNulls==1); %right next to the edge
                innerNulls(rowBad,:) = [];

                [rowBad,colBad] = find(innerNulls==NumCells);
                innerNulls(rowBad,:) = [];

                for ii = 1:size(innerNulls,1)
                    rowVal = innerNulls(ii,1); colVal = innerNulls(ii,2); 
                    %edge 1,2 next to eachother and 3,4 next to eachother
                    edge1 = (rowVal-1)*(NumCells-1) +(colVal-1); %each time through removes one edge previous
                    edge2 = (rowVal-1)*(NumCells-1) + colVal;
                    edge3 = (colVal-1)*(NumCells-1) + (rowVal-1);
                    edge4 = (colVal-1)*(NumCells-1) +  rowVal;

                    edgex(edgex_count:edgex_count+1) = [edge1 edge2];
                    edgey(edgey_count:edgey_count+1) = [edge3 edge4];

                    edgex_count = edgex_count+2; %added 2 edges
                    edgey_count = edgey_count+2; %added 2 edges
                end

                %throw out uncessary allocation 
                edgex(edgex==-1) = [];
                edgey(edgey==-1) = [];

                %finally get values
                edgex = unique(edgex);
                edgey = unique(edgey);
%                 edgeyshiftup = bxn_len-length(edgex)+edgey; 
                edgeyshiftup = bxn_len+edgey; 

                edges = [edgex edgeyshiftup]; %store all edges in one spot
            else
                %nullPos doesn't have value so no edges :P
                edgex = [];
                edgey = [];
                edges = []; 
            end %if(obj.nullPos) 
            
                %get jjPlot
                %idea is to start with the null and add zeros where needed...
                %only have to add one zero per edges

                %---plotting stuff--------------
                %matlab won't let be rotate until after we get it so, have
                %to get and then can do .' which plotting expects
                freqLen = length(obj.freq)
                for ii =1:freqLen
                    plateN = obj.plateNull(ii);
                    JJ_theta = plateN.JJ_theta;
                    JJ_phi = plateN.JJ_phi;
                    [JJx_theta, JJy_theta] = obj.plotCurrentHelper(JJ_theta.', edgex, edgey, 'theta pol')
                    [JJx_phi, JJy_phi] = obj.plotCurrentHelper(JJ_phi.', edgex, edgey, 'phi pol')
                end
        end
        
        function [JxMat,JyMat] = plotCurrentHelper(obj,jjPlot, edgex, edgey, plotTitle)
            %we're going to have to do the same thing essential 2 times per
            %frequency (2 polarizations)
            %this seems perfect for a helper function!
            %jjPlot: current array in form [Jx;Jy] 
            %edgex: nullpoints so I know where to place 0 -> Bxn
            %edgey; nullpoints so I know where to place 0 -> Byn
            %   this are the upshifted edgesy DON'T START AT 1
            %plotTitletitle: for plotting
            
            %combine edges
            edges = [edgex edgey];
            
            %place 0 where ever needed
            for ii = 1:length(edges)
                edgeLoc = edges(ii);

                jjPlot  = [jjPlot(1:edgeLoc-1) 0 jjPlot(edgeLoc:end)];

            end
            
            %---plotting stuff--------------
            %from here code is the same as plate plotting
            %get full plate for x,y values
            plateF = obj.plateFull(1); %this is just w
            %initialize matrix
            NumEdges =  obj.getNumCellsRow -1; %number edges in a row is number of cells minus 1
            XX = zeros(plateF.NumCells,NumEdges);
            YY = zeros(plateF.NumCells,NumEdges);
            JJMat = zeros(plateF.NumCells,NumEdges);

            for row = 1:plateF.NumCells
                for col = 1:NumEdges
                    XX(row,col) = plateF.Bxn_xx(col+NumEdges*(row-1));
                    YY(row,col) = plateF.Bxn_yy(col+NumEdges*(row-1));
                    JJMat(row,col) = jjPlot( col+NumEdges*(row-1));
                end
            end
            JxMat = JJMat;
            xx = XX(1,:); %yes, this is stupid way to do it, but reusing code
            yy = YY(1,:); %fix this later sarah
            figure;subplot(1,2,1)
            imagesc(xx,yy,abs(JxMat));
%                 figure;surf(XX,YY,abs(JJMat))
            title(['Jx ', plotTitle]);
    
            %plot Jy
            
            %amount we have to go up to get Jy essentially, M in book
            yup = obj.getBxnSize(); %Bxn length of the nullplate

            XX = zeros(NumEdges,plateF.NumCells);
            YY = zeros(NumEdges,plateF.NumCells);
            JJMat = zeros(NumEdges,plateF.NumCells);
            for row = 1:NumEdges
                for col = 1:plateF.NumCells
                    XX(row,col) = plateF.Byn_xx(row+NumEdges*(col-1));
                    YY(row,col) = plateF.Byn_yy(row+NumEdges*(col-1));
                    JJMat(row,col) = jjPlot(yup+row+NumEdges*(col-1));
                end
            end
            JyMat = JJMat;
            xx = XX(1,:); %yes, this is stupid way to do it, but reusing code
            yy = YY(1,:); %fix this later sarah
            subplot(1,2,2);
            imagesc(xx,yy,abs(JyMat));
%             figure;surf(XX,YY,abs(JJMat))
            title(['J_y ', plotTitle]);
            xlabel('x'); ylabel('y')

            
            
        end
        
        
% ---------------------- plotting null position ------------------        
        function plotNullPos(obj)
            %plotting what cells are getting nulled
            %Bxn so row = NumCell, col = NumEdge
            plateF = obj.plateFull(1);
            
            nullPosLocal = obj.nullPos; %have local value of nullPosLocal
                      
            del = plateF.Bxn_xx(2)-plateF.Bxn_xx(1); %get del 
            
            xx = linspace(del/2,plateF.len,plateF.NumCells);
            yy = xx; %because square
            % plotting stuff
%             [XX,YY] = meshgrid(xx,yy);
            nullPlot = ones(plateF.NumCells);

            for ii = 1:size(nullPosLocal,1)
                row = nullPosLocal(ii,1); col = nullPosLocal(ii,2);
                nullPlot(row,col) = 0;
            end
            % plotting
            figure; imagesc(nullPlot)
            title('with grid')
            hold on
            for ii = 1:plateF.NumCells-1
                xGrid = ii*ones(1,10)+1/2;
                yGrid = linspace(0,20,10);
                
                plot(xGrid,yGrid,'r')
                plot(yGrid,xGrid,'r') %because its a square :P
            end
            
            figure;imagesc('XData',xx,'YData',yy,'CData',nullPlot) %plot
            title('to size')
            hold on
            %plot grid
%             for ii = 1:plateF.NumCells-1
%                 xGrid = ii*del*ones(1,10);
%                 yGrid = linspace(0,plateF.len,10);
%                 
%                 plot(xGrid,yGrid,'r')
%                 plot(yGrid,xGrid,'r') %because its a square :P
%             end
            
        end
        

        
        %======================Export stuff========================================
        function null2csv(obj, filename)
            %export cellSize and null position to csv
            %first line will hold cell size and NumCells
            %everything after is null position
            %need to import into hfss
            NumCells = obj.plateFull.NumCells; 
            cellsize = obj.plateLength/NumCells; %plate length is real length not l0
            outMat = [ cellsize NumCells; obj.nullPos]; 
            csvwrite(filename, outMat)
        end
        
        function nullMat = nullPos2Mat(obj)
            % get nullpos array and output a matrix of 1 and zeros
            % representing the plate. 1=metal, 0 = hole
            
            nullPosLocal = obj.nullPos; %get location of holes
            nullMat = ones(obj.getNumCellsRow); %start with just metal
            
            %walk through the values and place zeros
            for ii = 1:size(nullPosLocal,1)
                row = nullPosLocal(ii,1); col = nullPosLocal(ii,2);
                nullMat(row,col) = 0;
            end
            
        end
    end
        
    
    methods (Static)
        function [row,col] = array2rowcol(xx, CellsPerRow)
            %takes in an array, finds the coordinates of the nulls, and
            %returns the corresponding cell as [row,col] points.
            %xx: the array 1=cell on, 0=cell off
            %CellsPerRow: how many cells in one row/col (assuming
            %square)... need to use this rather than NumCells
            %because of the quarter symettry stuff later (I think?)
            cellPos = find(xx==0); %positions x=0;
            %convert to [row,col]
            row = floor((cellPos-1)./(CellsPerRow))+1;
            col = cellPos-(row-1).*(CellsPerRow);
        
        end
        
        function fullArray = quarter2FullArray(xxQuarter,NumCells)
            %ready to do something stupid that works?? and lazy sarah likes works 
            %going to take the array defing a quarter of the matrix, turn it into a
            %matrix form, replicate the matrix as needed. Finally, that full matrix
            %will be turned into an array to be feed into nullNew or something...
            %because all of that expects an array
            
            %make into matrix
            quarterCell = NumCells/2;
            
            %treating top left of matrix as the "original" because symettry doesn't
            %care which cell quarter I play with
            quarterMat = reshape(xxQuarter,quarterCell,quarterCell);
            
            %crate full matrix
            %because of my wierd numbering (cell 1 is bottom left and increases to the
            %right to wrap around to row above) 
            fullMat = [quarterMat,     fliplr(quarterMat);
                flipud(quarterMat), rot90(quarterMat,2)];
            
            %take full matrix into array
            fullArray = reshape(fullMat,1,NumCells^2);
        end
        

        
    end
    
end

